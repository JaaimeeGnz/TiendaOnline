---
/**
 * src/pages/productos/index.astro
 * PÃ¡gina de productos estilo JD Sports
 */

import PublicLayout from "../../layouts/PublicLayout.astro";
import ProductCard from "../../components/product/ProductCard.astro";
import ProductFilters from "../../components/islands/ProductFilters";
import { supabaseClient } from "../../lib/supabase";

// âš ï¸ IMPORTANTE: Desabilitar pre-renderizaciÃ³n para que funcione con query params
export const prerender = false;

// Obtener parÃ¡metro de categorÃ­a
const url = new URL(Astro.request.url);
const categorySlug = url.searchParams.get("categoria");

console.log('ðŸ” URL completa:', Astro.request.url);
console.log('ðŸ” categorySlug:', categorySlug);
console.log('ðŸ” Â¿Es Rebajas?:', categorySlug === 'rebajas');

// Obtener categorÃ­as principales (sin parent)
const { data: mainCategories } = await supabaseClient
  .from("categories")
  .select("*")
  .is("parent_id", null)
  .eq("is_active", true)
  .order("display_order");

let products = [];
let categoryName = "";
let pageTitle = "Todos los Productos";
let mainCategoryId: string | null = null;
let subcategories: any[] = [];

// Verificar si es la categorÃ­a especial "rebajas"
const isRebajasCategory = categorySlug === 'rebajas';

if (isRebajasCategory) {
  // Mostrar productos con descuento (donde original_price_cents > price_cents)
  const { data: rebajasProducts } = await supabaseClient
    .from("products")
    .select("*")
    .eq("is_active", true)
    .order("featured", { ascending: false })
    .order("created_at", { ascending: false });

  // Filtrar solo productos que tienen descuento
  products = rebajasProducts?.filter(p => 
    p.original_price_cents && p.price_cents && p.original_price_cents > p.price_cents
  ) || [];
  
  // Si no hay productos con descuento, mostrar al menos los primeros 8 productos
  if (products.length === 0) {
    products = rebajasProducts?.slice(0, 8) || [];
  }
  
  categoryName = "Rebajas";
  pageTitle = "REBAJAS";
} else if (categorySlug) {
  // Obtener categorÃ­a (puede ser principal o subcategorÃ­a)
  const { data: category } = await supabaseClient
    .from("categories")
    .select("*")
    .eq("slug", categorySlug)
    .eq("is_active", true)
    .single();

  if (category) {
    categoryName = category.name;
    pageTitle = category.name;

    // Si es una subcategorÃ­a (tiene parent_id), obtener productos de esa subcategorÃ­a
    if (category.parent_id) {
      mainCategoryId = category.parent_id;
      const { data: categoryProducts } = await supabaseClient
        .from("products")
        .select("*")
        .eq("category_id", category.id)
        .eq("is_active", true)
        .order("featured", { ascending: false })
        .order("created_at", { ascending: false });

      products = categoryProducts || [];

      // Obtener subcategorÃ­as del padre para mostrar en el filtro
      const { data: subs } = await supabaseClient
        .from("categories")
        .select("*")
        .eq("parent_id", mainCategoryId)
        .eq("is_active", true)
        .order("display_order");
      
      subcategories = subs || [];
    } else {
      // Si es una categorÃ­a principal, obtener todos los productos de todas sus subcategorÃ­as
      mainCategoryId = category.id;
      
      // Obtener subcategorÃ­as
      const { data: subs } = await supabaseClient
        .from("categories")
        .select("*")
        .eq("parent_id", category.id)
        .eq("is_active", true)
        .order("display_order");
      
      subcategories = subs || [];

      // Obtener productos de todas las subcategorÃ­as
      if (subcategories.length > 0) {
        const subIds = subcategories.map(s => s.id);
        const { data: categoryProducts } = await supabaseClient
          .from("products")
          .select("*")
          .in("category_id", subIds)
          .eq("is_active", true)
          .order("featured", { ascending: false })
          .order("created_at", { ascending: false });

        products = categoryProducts || [];
      }
    }
  }
} else {
  const { data: allProducts } = await supabaseClient
    .from("products")
    .select("*")
    .eq("is_active", true)
    .order("featured", { ascending: false })
    .order("created_at", { ascending: false });

  products = allProducts || [];
}

// Obtener marcas Ãºnicas para filtros
const uniqueBrands = [...new Set(products.map((p) => p.brand).filter(Boolean))];
---

<PublicLayout title={`${pageTitle} - JGMarket`}>
  <div class="bg-jd-gray min-h-screen">
    <div class="max-w-7xl mx-auto px-4 py-8">
      <!-- Breadcrumb -->
      <nav class="flex items-center gap-2 mb-6 text-sm text-gray-500">
        <a href="/" class="hover:text-jd-black transition">Inicio</a>
        <span>/</span>
        <a href="/productos" class="hover:text-jd-black transition">Productos</a
        >
        {
          categoryName && (
            <>
              <span>/</span>
              <span class="text-jd-black font-bold">{categoryName}</span>
            </>
          )
        }
      </nav>

      <!-- Header -->
      <div
        class="flex flex-col md:flex-row md:items-center justify-between gap-4 mb-8"
      >
        <div>
          <h1 class="text-3xl md:text-4xl font-black text-jd-black uppercase">
            {pageTitle}
          </h1>
          <p class="text-gray-500 mt-1">{products.length} productos disponibles</p>
        </div>
      </div>

      <ProductFilters client:load products={products} brands={uniqueBrands} />
    </div>
  </div>
</PublicLayout>
