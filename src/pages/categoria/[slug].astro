---
/**
 * src/pages/categoria/[slug].astro
 * Página de listado por categoría con filtros dinámicos
 */

import PublicLayout from '../../layouts/PublicLayout.astro';
import ProductCard from '../../components/product/ProductCard.astro';
import ProductFilters from '../../components/islands/ProductFilters';
import { supabaseClient } from '../../lib/supabase';

// Pre-renderizar la página como HTML estático
export const prerender = true;

// Obtener todas las categorías para generar rutas estáticas
export async function getStaticPaths() {
  const { data: categories } = await supabaseClient
    .from('categories')
    .select('slug')
    .eq('is_active', true);

  return (categories || []).map((cat) => ({
    params: { slug: cat.slug },
  }));
}

const { slug } = Astro.params;

// Obtener categoría
const { data: category } = await supabaseClient
  .from('categories')
  .select('*')
  .eq('slug', slug)
  .eq('is_active', true)
  .single();

if (!category) {
  return Astro.redirect('/404');
}

// Obtener productos
let products = [];
let subcategories: any[] = [];
let uniqueBrands: string[] = [];

// Si es una subcategoría (tiene parent_id), obtener sus productos
if (category.parent_id) {
  const { data: subProducts } = await supabaseClient
    .from('products')
    .select('*')
    .eq('category_id', category.id)
    .eq('is_active', true)
    .order('featured', { ascending: false })
    .order('created_at', { ascending: false });
  
  products = subProducts || [];
} else {
  // Si es categoría principal, obtener productos de todas sus subcategorías o directos
  const { data: subs } = await supabaseClient
    .from('categories')
    .select('*')
    .eq('parent_id', category.id)
    .eq('is_active', true)
    .order('display_order');

  subcategories = subs || [];

  if (subcategories && subcategories.length > 0) {
    // Tiene subcategorías: obtener productos de las subcategorías
    const subIds = subcategories.map(s => s.id);
    const { data: mainProducts } = await supabaseClient
      .from('products')
      .select('*')
      .in('category_id', subIds)
      .eq('is_active', true)
      .order('featured', { ascending: false })
      .order('created_at', { ascending: false });
    
    products = mainProducts || [];
  } else {
    // No tiene subcategorías: obtener productos directos de esta categoría
    const { data: directProducts } = await supabaseClient
      .from('products')
      .select('*')
      .eq('category_id', category.id)
      .eq('is_active', true)
      .order('featured', { ascending: false })
      .order('created_at', { ascending: false });
    
    products = directProducts || [];
  }
}

// Extraer marcas únicas
uniqueBrands = [...new Set(products.map((p) => p.brand).filter(Boolean))].sort();
---

<PublicLayout
  title={`${category.name} - FashionMarket`}
  description={category.description}
>
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
    <!-- Breadcrumb -->
    <nav class="flex items-center gap-2 mb-8 text-sm text-neutral-gray_dark">
      <a href="/" class="hover:text-primary-800">Inicio</a>
      <span>/</span>
      <a href="/productos" class="hover:text-primary-800">Productos</a>
      <span>/</span>
      <span class="text-primary-800 font-semibold">{category.name}</span>
    </nav>

    <!-- Header -->
    <div class="mb-12">
      <h1 class="font-serif text-4xl font-bold text-primary-800 mb-3">
        {category.name}
      </h1>
      {category.description && (
        <p class="text-lg text-neutral-gray_dark max-w-2xl">
          {category.description}
        </p>
      )}
    </div>

    <!-- Filter bar and products grid -->
    <ProductFilters client:load products={products} brands={uniqueBrands} />
  </div>
</PublicLayout>
